#include <Arduino.h>
#include <stdint.h>
#include <avr/pgmspace.h>
#include "Chessuino.h"

#define DATABASE_SIZE 8082

void setup() {
    Serial.begin(9600);
}

void loop() {
    // Example usage
    displayAllPossibleMoves(1, "b2");

    // Add your main loop code here
}

void displayAllPossibleMoves(int pieceType, const char* sourceSquare) {
    c[0] = 0; // Reset move flag
    getByteBoard(); // Convert the board to a binary representation searchable in DB

    int sourceFile = sourceSquare[0] - 'a';
    int sourceRank = sourceSquare[1] - '1';

    for (int i = 0; i < DATABASE_SIZE; i++) {
        uint32_t move = pgm_read_dword_near(dataBase + i);

        int startFile = (move >> 24) & 0xFF;
        int startRank = (move >> 16) & 0xFF;
        int destFile = (move >> 8) & 0xFF;
        int destRank = move & 0xFF;
        int decodedPieceType = (move >> 28) & 0xF;

        // Validate if move is possible based on piece type and current board state
        if (decodedPieceType == pieceType && startFile == sourceFile && startRank == sourceRank &&
            validateMove(startFile, startRank, destFile, destRank, decodedPieceType)) {
            // Print or process the move information as needed.
            Serial.print("Move: ");
            Serial.print((char)('a' + startFile));
            Serial.print(startRank + 1);
            Serial.print(" to ");
            Serial.print((char)('a' + destFile));
            Serial.println(destRank + 1);
        }
    }
}

void searchDataBase() {
    c[0] = 0; // Reset move flag
    getByteBoard(); // Convert the board to a binary representation searchable in DB

    for (int i = 0; i < INDM; i++) {
        boolean found = true;
        int block = ((seed + i) % INDM) * 9; // Start in any block
        for (int j = 0; j < 8; j++) {
            uint32_t db = pgm_read_dword_near(dataBase + block + j);
            if (byteBoard[j] != db) {
                found = false;
                break;
            }
        }

        if (found) {
            uint32_t db = pgm_read_dword_near(dataBase + block + 8);
            c[4] = 0;
            c[3] = (char)(db & 0x000000FF) + '0';
            db >>= 8;
            c[2] = (char)(db & 0x000000FF) - 0xA + 'a';
            db >>= 8;
            c[1] = (char)(db & 0x000000FF) + '0';
            db >>= 8;
            c[0] = (char)(db & 0x000000FF) - 0xA + 'a';
            break;
        }
    }
}

bool validateMove(int startFile, int startRank, int destFile, int destRank, int pieceType) {
    // Perform move validation based on pieceType.
    bool isValidMove = false;

    switch (pieceType) {
        case 1:  // Pawn
            // Validate pawn moves
            if (startFile == destFile && destRank == startRank - 1) {
                // Regular one-square move forward
                isValidMove = true;
            } else if (startFile == destFile && destRank == startRank - 2 && startRank == 6) {
                // Initial two-square move forward
                isValidMove = true;
            } else if (abs(destFile - startFile) == 1 && destRank == startRank - 1) {
                // Diagonal capture
                isValidMove = true;
            }
            break;
        case 2:  // Knight
            // Validate knight moves
            int fileDifference = abs(destFile - startFile);
            int rankDifference = abs(destRank - startRank);
            if ((fileDifference == 1 && rankDifference == 2) || (fileDifference == 2 && rankDifference == 1)) {
                isValidMove = true;
            }
            break;
        case 3:  // Rook
            // Validate rook moves
            if (startFile == destFile || startRank == destRank) {
                isValidMove = true;
            }
            break;
        case 4:  // Bishop
            // Validate bishop moves
            int fileDelta = abs(destFile - startFile);
            int rankDelta = abs(destRank - startRank);
            if (fileDelta == rankDelta) {
                isValidMove = true;
            }
            break;
        case 5: // Queen
            // Validate queen moves
            if (startFile == destFile || startRank == destRank || abs(destFile - startFile) == abs(destRank - startRank)) {
                isValidMove = true;
            }
            break;
        case 6: // King
            // Validate king moves
            int fileDeltaKing = abs(destFile - startFile);
            int rankDeltaKing = abs(destRank - startRank);
            if ((fileDeltaKing == 1 || rankDeltaKing == 1) || (fileDeltaKing == 1 && rankDeltaKing == 1)) {
                isValidMove = true;
            }
            break;
    }
    return isValidMove;
}

void getByteBoard(){
    uint32_t n1, n2;
    char sym[17] = {0x0,0xF,0x1,0x3,0x6,0x4,0x2,0x5,0xF,0x9,0xF,0xB,0xE,0xC,0xA,0xD};
                   
    for(int i=0; i<8; i++){
        byteBoard[i] = 0;
        for(int j=0; j<8; j+=2){
            n1 = sym[b[16*i+j+0]&15];
            n2 = sym[b[16*i+j+1]&15];
            byteBoard[i] |= (n1<<((7-j)*4)) | (n2 << ((6-j)*4));
        }
    }    
}